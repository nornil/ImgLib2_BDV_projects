[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ImgLib2 and BigDataviewer projects",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Ecosystem",
    "section": "",
    "text": "How to work with the N5 API and ImgLib2?\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nHow to work with the N5 API and ImgLib2?\n\n\n\n\n\n\n\nimglib2\n\n\nn5\n\n\nhdf5\n\n\nzarr\n\n\njupyter\n\n\nnotebook\n\n\n\n\n\n\n\n\n\n\n\nSep 27, 2023\n\n\nStephan Saalfeld\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/How_to_work_with_the_N5_API_and_ImgLib2/How_to_work_with_the_N5_API_and_ImgLib2.html",
    "href": "posts/How_to_work_with_the_N5_API_and_ImgLib2/How_to_work_with_the_N5_API_and_ImgLib2.html",
    "title": "How to work with the N5 API and ImgLib2?",
    "section": "",
    "text": "In this notebook, we will learn how to work with the N5 API and ImgLib2.“,”“,”The N5 API unifies block-wise access to potentially very large n-dimensional data over a variety of storage backends. Those backends currently are the simple N5 format on the local filesystem, Google Cloud and AWS-S3, the HDF5 file format and Zarr. The ImgLib2 bindings use this API to make this data available as memory cached lazy cell images through ImgLib2.“,”“,”This notebook uses code and data examples from the ImgLib2 large data tutorial I2K2020 workshop (GitHub repository).“,”“,”First let’s add the necessary dependencies. We will load the n5-ij module which will transitively load ImgLib2 and all the N5 API modules that we will be using in this notebook. It will also load ImageJ which we will use to display data.”\n  \n%%loadFromPOM\n&lt;repository&gt;\n    &lt;id&gt;scijava.public&lt;/id&gt;\n    &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt;\n&lt;/repository&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5&lt;/artifactId&gt;\n    &lt;version&gt;2.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5-ij&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n\nLoad some data\nNow, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later.”"
  },
  {
    "objectID": "posts/How_to_work_with_the_N5_API_and_ImgLib2/2022-09-27-n5-imglib2.html",
    "href": "posts/How_to_work_with_the_N5_API_and_ImgLib2/2022-09-27-n5-imglib2.html",
    "title": "How to work with the N5 API and ImgLib2?",
    "section": "",
    "text": "Read and write ImgLib2 data with the N5 API\n\n\ntoc: false\nbranch: master\nbadges: true\ncomments: true\nauthor: Stephan Saalfeld\ncategories: [imglib2, n5, hdf5, zarr, jupyter, notebook]\n\nIn this notebook, we will learn how to work with the N5 API and ImgLib2.\nThe N5 API unifies block-wise access to potentially very large n-dimensional data over a variety of storage backends. Those backends currently are the simple N5 format on the local filesystem, Google Cloud and AWS-S3, the HDF5 file format and Zarr. The ImgLib2 bindings use this API to make this data available as memory cached lazy cell images through ImgLib2.\nThis notebook uses code and data examples from the ImgLib2 large data tutorial I2K2020 workshop (GitHub repository).\nFirst let’s add the necessary dependencies. We will load the n5-ij module which will transitively load ImgLib2 and all the N5 API modules that we will be using in this notebook. It will also load ImageJ which we will use to display data.\n\n%%loadFromPOM\n&lt;repository&gt;\n    &lt;id&gt;scijava.public&lt;/id&gt;\n    &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt;\n&lt;/repository&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5&lt;/artifactId&gt;\n    &lt;version&gt;2.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5-ij&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n\nNow, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later.\n\nimport com.google.gson.*;\nimport io.github.spencerpark.jupyter.kernel.display.common.*;\nimport io.github.spencerpark.jupyter.kernel.display.mime.*;\nimport net.imglib2.img.display.imagej.*;\nimport net.imglib2.view.*;\nimport net.imglib2.*;\n\ngetKernelInstance().getRenderer().createRegistration(RandomAccessibleInterval.class)\n        .preferring(MIMEType.IMAGE_PNG)\n        .supporting(MIMEType.IMAGE_JPEG, MIMEType.IMAGE_GIF)\n        .register((rai, context) -&gt; Image.renderImage(\n                ImageJFunctions.wrap(rai, rai.toString()).getBufferedImage(),\n                context));\n\ngetKernelInstance().getRenderer().createRegistration(String[].class)\n        .preferring(MIMEType.TEXT_PLAIN)\n        .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n        .register((array, context) -&gt; Text.renderCharSequence(Arrays.toString(array), context));\n\ngetKernelInstance().getRenderer().createRegistration(long[].class)\n        .preferring(MIMEType.TEXT_PLAIN)\n        .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n        .register((array, context) -&gt; Text.renderCharSequence(Arrays.toString(array), context));\n\ngetKernelInstance().getRenderer().createRegistration(Map.class)\n        .preferring(MIMEType.TEXT_PLAIN)\n        .supporting(MIMEType.TEXT_HTML, MIMEType.TEXT_MARKDOWN)\n        .register((map, context) -&gt; Text.renderCharSequence(map.toString(), context));\n\nWe will now open N5 datasets from some sources as lazy-loading ImgLib2 cell images. For opening the N5 readers, we will use the helper class N5Factory which parses the URL and/ or some magic byte in file headers to pick the right reader or writer for the various possible N5 backends. If you know which backend you are using, you should probably use the appropriate implementation directly, it’s not difficult.\n\nimport ij.*;\nimport net.imglib2.converter.*;\nimport net.imglib2.type.numeric.integer.*;\nimport org.janelia.saalfeldlab.n5.*;\nimport org.janelia.saalfeldlab.n5.ij.*;\nimport org.janelia.saalfeldlab.n5.imglib2.*;\n\n/* make an N5 reader, we start with a public container on AWS S3 */\nfinal var n5Url = \"https://janelia-cosem.s3.amazonaws.com/jrc_hela-2/jrc_hela-2.n5\";\nfinal var n5Group = \"/em/fibsem-uint16\";\nfinal var n5Dataset = n5Group + \"/s4\";\nfinal var n5 = new N5Factory().openReader(n5Url);\n\n/* open a dataset as a lazy loading ImgLib2 cell image */\nfinal RandomAccessibleInterval&lt;UnsignedShortType&gt; rai = N5Utils.open(n5, n5Dataset);\n\n/* This is a 3D volume, so let's show the center slice */\nViews.hyperSlice(rai, 2, rai.dimension(2) / 2);\n\nlog4j:WARN No appenders could be found for logger (com.amazonaws.auth.AWSCredentialsProviderChain).\nlog4j:WARN Please initialize the log4j system properly.\nlog4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\n\n\nCould not load AWS credentials, falling back to anonymous.\n\n\n\n\n\nThat’s a bit low on contrast, let’s make it look like TEM, and let’s show a few of those hyperslices through the 3D volume:\n\nvar raiContrast = Converters.convert(\n        rai,\n        (a, b) -&gt; b.setReal(Math.max(0, Math.min(255, 255 - 255 * (a.getRealDouble() - 26000) / 6000))),\n        new UnsignedByteType());\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 10 * 4), \"image/jpeg\");\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 2), \"image/jpeg\");\ndisplay(Views.hyperSlice(raiContrast, 2, rai.dimension(2) / 10 * 6), \"image/jpeg\");\n\n\n\n\n\n\n\n\n\n\n6e32749d-48d5-4c52-be9b-41c43bae02f4\n\n\nWe can list the attributes and their types of every group or dataset, and read any of them into matching types:\n\nvar groupAttributes = n5.listAttributes(n5Group);\nvar datasetAttributes = n5.listAttributes(n5Dataset);\n\ndisplay(\n    \"**\" + n5Group + \"** attributes are ```\" +\n        groupAttributes.toString().replace(\", \", \",\\n\").replace(\"{\", \"{\\n\") + \"```\",\n    \"text/markdown\");\ndisplay(\n    \"**\" + n5Dataset + \"** attributes are ```\" +\n        datasetAttributes.toString().replace(\", \", \",\\n\").replace(\"{\", \"{\\n\") + \"```\",\n    \"text/markdown\");\n\nvar n5Version = n5.getAttribute(\"/\", \"n5\", String.class);\nvar dimensions = n5.getAttribute(n5Dataset, \"dimensions\", long[].class);\nvar compression = n5.getAttribute(n5Dataset, \"compression\", Compression.class);\nvar dataType = n5.getAttribute(n5Dataset, \"dataType\", DataType.class);\n\ndisplay(n5Version);\ndisplay(dimensions);\ndisplay(compression);\ndisplay(dataType);\n\n\n/em/fibsem-uint16 attributes are { pixelResolution=class java.lang.Object, multiscales=class [Ljava.lang.Object;, n5=class java.lang.String, scales=class [Ljava.lang.Object;, axes=class [Ljava.lang.String;, name=class java.lang.String, units=class [Ljava.lang.String;}\n\n\n/em/fibsem-uint16/s4 attributes are { transform=class java.lang.Object, pixelResolution=class java.lang.Object, dataType=class java.lang.String, name=class java.lang.String, compression=class java.lang.Object, blockSize=class [J, dimensions=class [J}\n\n\n2.0.0\n\n\n[750, 100, 398]\n\n\norg.janelia.saalfeldlab.n5.GzipCompression@673562cc\n\n\nuint16\n\n\n6c5c9bc2-ea28-4685-9658-a8fbf3c65df4\n\n\nLet’s save the contrast adjusted uin8 version of the volume into three N5 supported containers (N5, Zarr, and HDF5), parallelize writing for N5 and Zarr:\n\nimport java.nio.file.*;\n\n/* create a temporary directory */\nPath tmpDir = Files.createTempFile(\"\", \"\");\nFiles.delete(tmpDir);\nFiles.createDirectories(tmpDir);\nvar tmpDirStr = tmpDir.toString();\n\ndisplay(tmpDirStr);\n\n/* get the dataset attributes (dataType, compression, blockSize, dimensions) */\nfinal var attributes = n5.getDatasetAttributes(n5Dataset);\n\n/* use 10 threads to parallelize copy */\nfinal var exec = Executors.newFixedThreadPool(10);\n\n/* save this dataset into a filsystem N5 container */\ntry (final var n5Out = new N5Factory().openFSWriter(tmpDirStr + \"/test.n5\")) {\n    N5Utils.save(raiContrast, n5Out, n5Dataset, attributes.getBlockSize(), attributes.getCompression(), exec);\n}\n\n/* save this dataset into a filesystem Zarr container */\ntry (final var zarrOut = new N5Factory().openZarrWriter(tmpDirStr + \"/test.zarr\")) {\n    N5Utils.save(raiContrast, zarrOut, n5Dataset, attributes.getBlockSize(), attributes.getCompression(), exec);\n}\n\n/* save this dataset into an HDF5 file, parallelization does not help here */\ntry (final var hdf5Out = new N5Factory().openHDF5Writer(tmpDirStr + \"/test.hdf5\")) {\n    N5Utils.save(raiContrast, hdf5Out, n5Dataset, attributes.getBlockSize(), attributes.getCompression());\n}\n\n/* shot down the executor service */\nexec.shutdown();\n\ndisplay(Files.list(tmpDir).map(a -&gt; a.toString()).toArray(String[]::new));\n\n/tmp/303790804299695858\n\n\n[/tmp/303790804299695858/test.hdf5, /tmp/303790804299695858/test.n5, /tmp/303790804299695858/test.zarr]\n\n\nd55081b3-d9fd-4208-9bae-181c9253712a\n\n\nNow let us look at them and see if they all contain the same data:\n\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.n5\")) {\n    final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n    display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");\n}\n\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.zarr\")) {\n    final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n    display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");    \n}\n\ntry (final var n5 = new N5Factory().openReader(tmpDirStr + \"/test.hdf5\")) {\n    final RandomAccessibleInterval&lt;UnsignedByteType&gt; rai = N5Utils.open(n5, n5Dataset);\n    display(Views.hyperSlice(rai, 2, rai.dimension(2) / 2), \"image/jpeg\");        \n}\n\n\n\n\n\n\n\n\n\n\nLet’s clean up temporary storage before we end this tutorial.\n\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.n5\")) {\n    n5.remove();\n}\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.zarr\")) {\n    n5.remove();\n}\ntry (var n5 = new N5Factory().openWriter(tmpDirStr + \"/test.hdf5\")) {\n    n5.remove();\n}\nFiles.delete(tmpDir);"
  },
  {
    "objectID": "posts/2022-09-27-n5-imglib2/2022-09-27-n5-imglib2.html",
    "href": "posts/2022-09-27-n5-imglib2/2022-09-27-n5-imglib2.html",
    "title": "How to work with the N5 API and ImgLib2?",
    "section": "",
    "text": "Read and write ImgLib2 data with the N5 API\n\n\ntoc: false\nbranch: master\nbadges: true\ncomments: true\nauthor: Stephan Saalfeld\ncategories: [imglib2, n5, hdf5, zarr, jupyter, notebook]\n\nIn this notebook, we will learn how to work with the N5 API and ImgLib2.\nThe N5 API unifies block-wise access to potentially very large n-dimensional data over a variety of storage backends. Those backends currently are the simple N5 format on the local filesystem, Google Cloud and AWS-S3, the HDF5 file format and Zarr. The ImgLib2 bindings use this API to make this data available as memory cached lazy cell images through ImgLib2.\nThis notebook uses code and data examples from the ImgLib2 large data tutorial I2K2020 workshop (GitHub repository).\nFirst let’s add the necessary dependencies. We will load the n5-ij module which will transitively load ImgLib2 and all the N5 API modules that we will be using in this notebook. It will also load ImageJ which we will use to display data.\n%%loadFromPOM\n&lt;repository&gt;\n    &lt;id&gt;scijava.public&lt;/id&gt;\n    &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt;\n&lt;/repository&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5&lt;/artifactId&gt;\n    &lt;version&gt;2.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5-ij&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\nNow, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later."
  },
  {
    "objectID": "ecosystem.html",
    "href": "ecosystem.html",
    "title": "Ecosystem",
    "section": "",
    "text": "BigDataProcessor2\n\n\n\n\n\n\n\nimglib2\n\n\nn5\n\n\nhdf5\n\n\nzarr\n\n\njupyter\n\n\nnotebook\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "ecosystem/BigDataProcessor/How_to_work_with_the_N5_API_and_ImgLib2.html",
    "href": "ecosystem/BigDataProcessor/How_to_work_with_the_N5_API_and_ImgLib2.html",
    "title": "How to work with the N5 API and ImgLib2?",
    "section": "",
    "text": "In this notebook, we will learn how to work with the N5 API and ImgLib2.“,”“,”The N5 API unifies block-wise access to potentially very large n-dimensional data over a variety of storage backends. Those backends currently are the simple N5 format on the local filesystem, Google Cloud and AWS-S3, the HDF5 file format and Zarr. The ImgLib2 bindings use this API to make this data available as memory cached lazy cell images through ImgLib2.“,”“,”This notebook uses code and data examples from the ImgLib2 large data tutorial I2K2020 workshop (GitHub repository).“,”“,”First let’s add the necessary dependencies. We will load the n5-ij module which will transitively load ImgLib2 and all the N5 API modules that we will be using in this notebook. It will also load ImageJ which we will use to display data.”\n  \n%%loadFromPOM\n&lt;repository&gt;\n    &lt;id&gt;scijava.public&lt;/id&gt;\n    &lt;url&gt;https://maven.scijava.org/content/groups/public&lt;/url&gt;\n&lt;/repository&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5&lt;/artifactId&gt;\n    &lt;version&gt;2.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.janelia.saalfeldlab&lt;/groupId&gt;\n    &lt;artifactId&gt;n5-ij&lt;/artifactId&gt;\n    &lt;version&gt;3.2.2&lt;/version&gt;\n&lt;/dependency&gt;\n\nLoad some data\nNow, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later.”"
  },
  {
    "objectID": "ecosystem/BigDataProcessor2/BigDataProcessor2.html",
    "href": "ecosystem/BigDataProcessor2/BigDataProcessor2.html",
    "title": "BigDataProcessor2",
    "section": "",
    "text": "Load some data\nNow, we register a simple renderer that uses ImgLib2’s ImageJ bridge and Spencer Park’s image renderer to render the first 2D slice of a RandomAccessibleInterval into the notebook. We also add a renderer for arrays and maps, because we want to list directories and attributes maps later.”"
  },
  {
    "objectID": "index.html#this-is-the-joint-landing-page-for-imglib2-and-bigdataviewer-projects",
    "href": "index.html#this-is-the-joint-landing-page-for-imglib2-and-bigdataviewer-projects",
    "title": "ImgLib2 and BigDataviewer projects",
    "section": "This is the joint landing page for ImgLib2 and BigDataViewer projects!",
    "text": "This is the joint landing page for ImgLib2 and BigDataViewer projects!"
  }
]